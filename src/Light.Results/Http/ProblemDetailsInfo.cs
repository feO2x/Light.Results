using System;
using System.Net;

namespace Light.Results.Http;

/// <summary>
/// Represents the typical members of problem details as defined in RFC 7807/9457.
/// See https://www.rfc-editor.org/rfc/rfc9457.html#section-3.1 for details.
/// </summary>
public readonly record struct ProblemDetailsInfo
{
    /// <summary>
    /// <para>
    /// The "type" member is a JSON string containing a URI reference that identifies the problem type.
    /// Consumers MUST use the "type" URI (after resolution, if necessary) as the problem type's primary identifier.
    /// </para>
    /// <para>
    /// When this member is not present, its value is assumed to be "about:blank".
    /// </para>
    /// <para>
    /// If the type URI is a locator (e.g., those with an "http" or "https" scheme), dereferencing it SHOULD provide
    /// human-readable documentation for the problem type. However, consumers SHOULD NOT automatically dereference the
    /// type URI, unless they do so when providing information to developers (e.g., when a debugging tool is in use).
    /// </para>
    /// <para>
    /// When "type" contains a relative URI, it is resolved relative to the document's base URI, as per
    /// https://www.rfc-editor.org/rfc/rfc3986#section-5. However, using relative URIs can cause confusion, and they
    /// might not be handled correctly by all implementations.
    /// </para>
    /// <para>
    /// For example, if the two resources "https://api.example.org/foo/bar/123" and "https://api.example.org/widget/456"
    /// both respond with a "type" equal to the relative URI reference "example-problem", when resolved they will
    /// identify different resources ("https://api.example.org/foo/bar/example-problem" and
    /// "https://api.example.org/widget/example-problem", respectively). As a result, it is RECOMMENDED that absolute
    /// URIs be used in "type" when possible and that when relative URIs are used, they include the full path
    /// (e.g., "/types/123").
    /// </para>
    /// <para>
    /// The type URI is allowed to be a non-resolvable URI. For example, the tag URI scheme [TAG] can be used to
    /// uniquely identify problem types: tag:example@example.org,2021-09-17:OutOfLuck
    /// </para>
    /// <para>
    /// However, resolvable type URIs are encouraged by this specification because it might become desirable to resolve
    /// the URI in the future. For example, if an API designer used the URI above and later adopted a tool that resolves
    /// type URIs to discover information about the error, taking advantage of that capability would require switching
    /// to a resolvable URI, creating a new identity for the problem type and thus introducing a breaking change.
    /// </para>
    /// <para>
    /// By default, the <see cref="ErrorCategoryExtensionsForHttp.GetTypeUri" /> method is used to obtain the type from a result.
    /// </para>
    /// </summary>
    public required string Type { get; init; }

    /// <summary>
    /// <para>
    /// The "status" member is a JSON number indicating the HTTP status code
    /// (https://www.rfc-editor.org/rfc/rfc9110#section-15) generated by the origin server for this occurrence of
    /// the problem.
    /// </para>
    /// <para>
    /// The "status" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of
    /// the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP
    /// software that does not understand this format still behaves correctly. See
    /// https://www.rfc-editor.org/rfc/rfc9457.html#security-considerations for further caveats regarding its use.
    /// </para>
    /// <para>
    /// Consumers can use the status member to determine what the original status code used by the generator was when it
    /// has been changed (e.g., by an intermediary or cache) and when a message's content is persisted without HTTP
    /// information. Generic HTTP software will still use the HTTP status code.
    /// </para>
    /// <para>
    /// By default, the <see cref="ErrorCategoryExtensionsForHttp.ToHttpStatusCode" /> method is used to obtain the HTTP status code
    /// from a result.
    /// </para>
    /// </summary>
    public required HttpStatusCode Status { get; init; }

    /// <summary>
    /// <para>
    /// The "title" member is a JSON string containing a short, human-readable summary of the problem type.
    /// </para>
    /// <para>
    /// It SHOULD NOT change from occurrence to occurrence of the problem, except for localization (e.g., using
    /// proactive content negotiation; see https://www.rfc-editor.org/rfc/rfc9110#section-12.1).
    /// </para>
    /// <para>
    /// The "title" string is advisory and is included only for users who are unaware of and cannot discover the
    /// semantics of the type URI (e.g., during offline log analysis).
    /// </para>
    /// <para>
    /// By default, the <see cref="ErrorCategoryExtensionsForHttp.GetTitle" /> method is used to obtain the title from a result.
    /// </para>
    /// </summary>
    public required string Title { get; init; }

    /// <summary>
    /// <para>
    /// The "detail" member is a JSON string containing a human-readable explanation specific to this occurrence of
    /// the problem.
    /// </para>
    /// <para>
    /// The "detail" string, if present, ought to focus on helping the client correct the problem, rather than giving
    /// debugging information.
    /// </para>
    /// <para>
    /// Consumers SHOULD NOT parse the "detail" member for information; extensions are more suitable and less
    /// error-prone ways to obtain such information.
    /// </para>
    /// </summary>
    public string? Detail { get; init; }

    /// <summary>
    /// <para>
    /// The "instance" member is a JSON string containing a URI reference that identifies the specific occurrence of
    /// the problem.
    /// </para>
    /// <para>
    /// When the "instance" URI is dereferenceable, the problem details object can be fetched from it. It might also
    /// return information about the problem occurrence in other formats through use of proactive content negotiation
    /// (see https://www.rfc-editor.org/rfc/rfc9110#section-12.5.1).
    /// </para>
    /// <para>
    /// When the "instance" URI is not dereferenceable, it serves as a unique identifier for the problem occurrence
    /// that may be of significance to the server but is opaque to the client.
    /// </para>
    /// <para>
    /// When "instance" contains a relative URI, it is resolved relative to the document's base URI, as per
    /// https://www.rfc-editor.org/rfc/rfc9457.html#RFC3986. However, using relative URIs can cause confusion, and they
    /// might not be handled correctly by all implementations.
    /// </para>
    /// <para>
    /// For example, if the two resources "https://api.example.org/foo/bar/123" and "https://api.example.org/widget/456"
    /// both respond with an "instance" equal to the relative URI reference "example-instance", when resolved they will
    /// identify different resources ("https://api.example.org/foo/bar/example-instance" and
    /// "https://api.example.org/widget/example-instance", respectively). As a result, it is RECOMMENDED that absolute
    /// URIs be used in "instance" when possible, and that when relative URIs are used, they include the full path
    /// (e.g., "/instances/123").
    /// </para>
    /// </summary>
    public string? Instance { get; init; }

    /// <summary>
    /// Creates the default problem details info from the given errors.
    /// </summary>
    /// <param name="errors">The errors instance</param>
    /// <param name="firstCategoryIsLeadingCategory">
    /// If true, the first error in <paramref name="errors" /> will be used to determine the type URI, status code, title
    /// and detail. If false, the common category is used if all errors share it, or otherwise
    /// <see cref="ErrorCategory.Unclassified" />. Defaults to true.
    /// </param>
    /// <returns>The problem details info containing values for Type, Status, Title and Detail.</returns>
    /// <exception cref="ArgumentException">Thrown when <paramref name="errors" /> is empty.</exception>
    public static ProblemDetailsInfo CreateDefault(Errors errors, bool firstCategoryIsLeadingCategory = true)
    {
        if (errors.IsEmpty)
        {
            throw new ArgumentException(
                "The errors must contain at least one error to be used as the basis for problem details",
                nameof(errors)
            );
        }

        var errorCategory = errors.GetLeadingCategory(firstCategoryIsLeadingCategory);
        return new ProblemDetailsInfo
        {
            Type = errorCategory.GetTypeUri(),
            Status = errorCategory.ToHttpStatusCode(),
            Title = errorCategory.GetTitle(),
            Detail = errorCategory.GetDetail()
        };
    }
}
